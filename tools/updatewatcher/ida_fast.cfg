//  IDA configuration file

//
//  PLEASE READ THIS NOTICE CAREFULLY
//  ---------------------------------
//
//      Configuration file is read 2 times.
//      First pass is performed as soon as IDA is loaded
//      Second pass is performed when IDA determines the processor type
//
//      All processor specific tuning is located at the second part of this file.
//
//      Please note that some parameters occur several times in the file:
//        each occurence for different processor.
//
//      User-specific tuning can be made in idauser.cfg file
//                      (see end of this file)
//
//      You may temporarily change a configuration variable by using
//      command line switches: -d and -D
//      The -d switch is processed at the first  configuration pass.
//      The -D switch is processed at the second configuration pass.
//      Example:
//                ida -dVPAGESIZE=0x4000 -c newfile
//
//      C-like preprocessor directives are allowed.
//      You can use C-like constants in this file.
//

//=========================================================================
//                      F I R S T   P A S S
//=========================================================================
//
//      First pass.
//      Define file extension table, memory sizes, screen mode
//      and OS specific parameters.
//
//-------------------------------------------------------------------------
#ifdef ____             // first pass of config starts here
//
//      Default processor configuration table
//      -------------------------------------
//
//      The default processor will be used if the processor type is
//      not specified in the command line.
//      Feel free to customize this table.
//
DEFAULT_PROCESSOR = {
/* Extension    Processor */
  "com" :       ""                      // IDA will try the specified
  "exe" :       ""                      // extensions if no extension is
  "dll" :       ""                      // given.
  "drv" :       ""
  "sys" :       ""
  "bin" :       ""                      // Empty processor means the default processor
  "ovl" :       ""
  "ovr" :       ""
  "ov?" :       ""
  "nlm" :       ""
  "lan" :       ""
  "dsk" :       ""
  "obj" :       ""
  "prc" :       "68000"                 // PalmPilot programs
  "axf" :       "arm"
  "h68" :       "68000"                 // MC68000 for *.H68 files
  "i51" :       "8051"                  // i8051   for *.I51 files
  "sav" :       "pdp11"                 // PDP-11  for *.SAV files
  "rom" :       "z80"                   // Z80     for *.ROM files
  "cla*":       "java"
  "s19":        "6811"
  "epoc":       "arm"
  "o":          ""
  "*":          ""                      // Default processor
}

WORKDIR                 = ""            // Work direcrtory. IDA will create
                                        // temporary database files there.
                                        // Set to a directory on a separate disk
                                        // to improve open/close performance
                                        // of huge databases.

// Plugins to automatically launch when opening an existing idb file.
// Currently we autorun the 'windbg' plugin to display Windows Crash Dump files.
AUTORUN_PLUGINS =
{
/* FileType        Plugin and argument */
#ifdef __NT__
  "windmp" :       "windbg_user:-2"
#endif
}

//
//      Memory configuration parameters
//      -------------------------------
// NOTES:
//
//      1. DATABASE_MEMORY determines how much memory will be allocated
//         for names, strings, xrefs, functions, etc. If it is == 0 then
//         IDA uses the following alrogithm:
//
//              DATABASE_MEMORY = new_file
//                              ? input_file_size * 4
//                              : old_btree_size/2
//         IDA never allocates more than 128MB in this case.
//
//      2. page sizes (VPAGESIZE and NPAGESIZE) must be powers of 2.
//
//      3. if VPAGES == 0 then 32bit IDA reserves memory by the following
//         alrogithm:
//
//              VMEM = new_file
//                              ? input_file_size*4
//                              : allocated_addressing_space;
//
//              VPAGES = VMEM / VPAGESIZE
//
//      4. Here is the total amount of memory allocated when IDA starts:
//
//           TOTAL = DATABASE_MEMORY + VPAGESIZE*VPAGES + NPAGESIZE*NPAGES
//


DATABASE_MEMORY         = 0             // Size of btree buffer in bytes.
VPAGESIZE               = 8192          // Virtual memory page size
                                        // (effective for new bases only)
                                        // 8192 => 128MB addressing space is the limit
VPAGES                  = 0             // Size of virtual memory window
                                        // (in pages)
NPAGESIZE               = 8192          // Name pointers page size
                                        // (effective for new bases only)
NPAGES                  = 32            // how big will be the memory buffer?
                                        // (each name uses 4 bytes)
                                        // The default settings allow to keep
                                        // in memory 2^16 names. The remaining
                                        // names will be swapped to the disk.

// limit the xref cache size to this amount of bytes
// (0 to disable the limit)
#ifdef __X64__
  XREF_CACHE_LIMIT = 0
#else
  XREF_CACHE_LIMIT = 1500000000
#endif


// the following maps a character encoding, to one (or many)
// associated 'culture'(s).
//
// This is used to decide what codepoints should automatically be
// added to the sets of codepoints that contain the CURRENT_CULTURE
// entry, in case the IDB has a single-byte (and non-UTF-8) encoding.
// (See StrlitChars, etc... for more info.)
//
// Note: if a 'CULTURE' configuration directive is specified, it will
// override the culture(s) derived from the encoding.
//
// Note: the encodings below that consist of only a number, are considered
// windows ANSI codepages, and will map to multiple encodings whose
// names contain that codepage. E.g., 1252 will map to: "windows-1252",
// "windows1252", "cp1252", "1252".
ENCODING_CULTURES =
        1250: Central_Europe,
        1251: Cyrillic,
        1252: Latin_1,
        1253: Greek,
        1254: Turkish,
        1255: Hebrew,
        1256: Arabic,
        1257: Baltic,
        1258: Vietnam,
        874: Thai,
        cp863: Latin_1 Greek;


//-------------------------------------------------------------------------
// The following drives the upgrade of pre-7.0 databases, regarding the
// conversion of non-ASCII user strings (comments, identifiers, etc...)
// This does not affect string literals in any way.
//-------------------------------------------------------------------------

// In case UPGRADE_CPSTRINGS_SRCENC[A] (see below) is not specified,
// should IDA warn (in the "Output window") when it performed conversion
// of strings with what it believes might be the source encoding?
// (Note: if UPGRADE_CPSTRINGS_SRCENC[A] is specified, this has no effect.)
UPGRADE_CPSTRINGS_SILENT = NO

// The source encoding for non-ASCII identifiers, comments, etc..
// UPGRADE_CPSTRINGS_SRCENC = "CP855"; // cyrillic OEM codepage

// Some bits of data were stored in a separate encoding than the
// comments (i.e., they were stored in the local ANSI codepage,
// not the local OEM codepage). This lets you specify that
// encoding.
// UPGRADE_CPSTRINGS_SRCENCA = "windows-1251"; // cyrillic ANSI codepage

// NOTE: it's possible to pass config directives to IDA directly
// from the command line. The following terminal commands are
// therefore valid:
//
// * Have IDA to silently perform conversion, using whatever
//   it thinks might be the source encoding (guessed from the system):
// $ ida -dUPGRADE_CPSTRINGS_SILENT=YES some695.idb
//
// * Have IDA to silently perform conversion, using Cyrillic
//   OEM codepage as the source encoding:
// $ ida -dUPGRADE_CPSTRINGS_SRCENC=\"CP855\" some695.idb
// (notice the escaping of the CP855 string. It's necessary
// because config directives on the command line are parsed
// using the exact same C-style lexer as the config file, and
// thus double-quotes are expected around a string literal.)

#else                   // first pass ends here


//=========================================================================
//
//                      S E C O N D   P A S S
//
//=========================================================================
//      Second pass starts here.
//      At the second pass IDA defines a macro "__<processor>__"
//      For example, if the user specified 'z80' processor,
//      then __Z80__ will be defined.
//      (note that the processor name is converted to uppercase)
//      Also, a processor module file name is used to create a macro
//      "__<idpname>__". For example, IBM PC loader defines "__PC__" symbol.
//      These macros can be used for processor specific tuning, for example:
//
//      #ifdef __Z80__
//        MAX_AUTONAME_LEN = 8
//      #endif
//
//-------------------------------------------------------------------------
//
//      General parameteres for all processors
//      (processor specific parameters are below)
//
//-------------------------------------------------------------------------

PACK_DATABASE           = 2             // 0 - don't pack at all
                                        // 1 - pack database (store)
                                        // 2 - pack database (deflate)
CREATE_BACKUPS          = NO            // Create database backups
COLLECT_GARBAGE         = YES           // Collect garbage when saving the database
ABANDON_DATABASE        = NO            // Set to YES to not save database on exit (useful in batch mode)
STORE_USER_INFO         = YES           // Store information about the user
                                        // who created the database in the database.
                                        // Use DelUserInfo() IDC function to delete
                                        // user info in existing databases.

CHECK_MANUAL_ARGS       = YES           // Check equality of manual operands
                                        // entered by Alt-F1

// Program to visualize graphs

#ifdef __NT__
// program to run after generating the graph. The filename is added at the end
GRAPH_VISUALIZER        = "qwingraph.exe -remove -timelimit 10"
// format of graph files to generate. Possible values: "GDL" and "DOT"
GRAPH_FORMAT            = "GDL"
// GRAPH_VISUALIZER        = "C:\\PROGRA~2\\GRAPHV~1.3\\BIN\\dotty.exe"
// GRAPH_FORMAT            = "DOT"
#else
#ifdef __LINUX__
GRAPH_VISUALIZER        = "qwingraph -remove -timelimit 10"
GRAPH_FORMAT            = "GDL"
//GRAPH_VISUALIZER        = "/usr/bin/dotty"
//GRAPH_FORMAT            = "DOT"
#else # __MAC__
GRAPH_VISUALIZER        = "qwingraph -remove -timelimit 10"
GRAPH_FORMAT            = "GDL"
#endif
#endif

//-------------------------------------------------------------------------
//
//      Analysis parameters
//
//-------------------------------------------------------------------------

ENABLE_ANALYSIS         = YES   // Background analysis is enabled

SHOW_INDICATOR          = YES   // Show background analysis indicator

#define AF_CODE         0x00000001      // Trace execution flow
#define AF_MARKCODE     0x00000002      // Mark typical code sequences as code
#define AF_JUMPTBL      0x00000004      // Locate and create jump tables
#define AF_PURDAT       0x00000008      // Control flow to data segment is ignored
#define AF_USED         0x00000010      // Analyze and create all xrefs
#define AF_UNK          0x00000020      // Delete instructions with no xrefs
#define AF_PROCPTR      0x00000040      // Create function if data xref data->code32 exists
#define AF_PROC         0x00000080      // Create functions if call is present
#define AF_FTAIL        0x00000100      // Create function tails
#define AF_LVAR         0x00000200      // Create stack variables
#define AF_STKARG       0x00000400      // Propagate stack argument information
#define AF_REGARG       0x00000800      // Propagate register argument information
#define AF_TRACE        0x00001000      // Trace stack pointer
#define AF_VERSP        0x00002000      // Perform full SP-analysis. (\ph{verify_sp})
#define AF_ANORET       0x00004000      // Perform 'no-return' analysis
#define AF_MEMFUNC      0x00008000      // Try to guess member function types
#define AF_TRFUNC       0x00010000      // Truncate functions upon code deletion
#define AF_STRLIT       0x00020000      // Create string literal if data xref exists
#define AF_CHKUNI       0x00040000      // Check for unicode strings
#define AF_FIXUP        0x00080000      // Create offsets and segments using fixup info
#define AF_DREFOFF      0x00100000      // Create offset if data xref to seg32 exists
#define AF_IMMOFF       0x00200000      // Convert 32bit instruction operand to offset
#define AF_DATOFF       0x00400000      // Automatically convert data to offsets
#define AF_FLIRT        0x00800000      // Use flirt signatures
#define AF_SIGCMT       0x01000000      // Append a signature name comment for recognized anonymous library functions
#define AF_SIGMLT       0x02000000      // Allow recognition of several copies of the same function
#define AF_HFLIRT       0x04000000      // Automatically hide library functions
#define AF_JFUNC        0x08000000      // Rename jump functions as j_...
#define AF_NULLSUB      0x10000000      // Rename empty functions as nullsub_...
#define AF_DODATA       0x20000000      // Coagulate data segs at the final pass
#define AF_DOCODE       0x40000000      // Coagulate code segs at the final pass
#define AF_FINAL        0x80000000      // Final pass of analysis
ANALYSIS        = 0xDFFF9FF7ULL // This value is combination of the bits defined
                                // above

#define AF2_DOEH        0x00000001      /// Handle EH information
#define AF2_DORTTI      0x00000002      /// Handle RTTI information
ANALYSIS2       = 0x00000002ULL // This value is combination of the bits defined
                                // above

FLAT_OFF32              = NO    // treat REF_OFF32 as 32-bit offset (otherwise try SEG16:OFF16 for 16bit segments)

//-------------------------------------------------------------------------
//
//      Text representation
//
//-------------------------------------------------------------------------

OPCODE_BYTES            = 0   // don't display instruction/data bytes
                              // The 'default' configuration in the registry may
                              // override this value
INDENTION               = 16  // Indention of instructions
                              // The 'default' configuration in the registry may
                              // override this value
COMMENTS_INDENTION      = 40  // Indention of short comments
MAX_TAIL                = 16  // Tail depth (used to gather xref info)
MAX_XREF_LENGTH         = 80  // Maximal length of line with cross-references
MAX_DATALINE_LENGTH     = 70  // Data directives (db,dw, etc):
                              //   max length of argument string
SHOW_AUTOCOMMENTS       = NO  // Display comments for every instruction
                              // Advanced users will turn this off
                              // Please note that there is another definition
                              // for IBM PC below
SHOW_BASIC_BLOCKS       = NO  // Generate an empty line at the end of a basic block
SHOW_BORDERS            = YES // Borders between data/code
SHOW_EMPTYLINES         = YES // Generate empty line to make disassembly more readable
SHOW_LINEPREFIXES       = YES // Show line prefixes (like 1000:0000)
SHOW_SEGMENTS           = YES // Show segments in addresses
USE_SEGMENT_NAMES       = YES // Show segment names instead of numbers
SHOW_REPEATABLE_COMMENTS= YES // Show repeatable comments (disabling this increases IDA speed)
SHOW_SP                 = NO  // Show stack pointer at the start of lines
                              // The 'default' configuration in the registry may
                              // override this value
SHOW_SUSPICIOUS         = NO  // Show <void> marks (the red/orange color is bright enough)
SHOW_XREFS              = 2   // Show 2 cross-references (the rest is accessible by Ctrl-X)
SHOW_XREF_FUNC          = YES // Show function offsets in xrefs
SHOW_XREF_TYPES         = YES // Show xref type marks
SHOW_XREF_VALUES        = YES // If not, xrefs are displayed as "..."
SHOW_SEGXREFS           = YES // Show segment part of addresses in cross-references
#if defined(__JAVA__)
SHOW_SOURCE_LINNUM      = YES // Show source line numbers
#else
SHOW_SOURCE_LINNUM      = NO  // Show source line numbers
#endif
SHOW_TRYBLOCKS          = YES // Show try block line information
SHOW_ASSUMES            = YES // Generate 'assume' directives
SHOW_ORIGINS            = YES // Generate 'org' directives
SHOW_REFCMTS            = 1   // Show 1 reference to ASCII strings or demangled names
                              // (the rest is accessible by Ctrl-J)

DEL_CODE_COMMENTS       = YES // Delete a comment attached to an instruction
                              // when the instruction is deleted
MAX_ITEM_LINES          = 25000 // Maximum number of lines for one item (one instruction or data)

//-------------------------------------------------------------------------
//      Colors
//-------------------------------------------------------------------------
#ifdef __GUI__
//PROLOG_COLOR = 0xE0E0E0            // grey
//EPILOG_COLOR = 0xE0FFE0            // light green
//SWITCH_COLOR = 0xE0E0FF            // pink
#endif

//-------------------------------------------------------------------------
//
//      Floating point numbers
//
//-------------------------------------------------------------------------
FPNUM_DIGITS            = 0   // If non-zero, specifies the number of digits printed
                              // after the decimal point. The printed number may be
                              // truncated if necessary.
                              // If FPNUM_DIGITS is non-zero, FPNUM_LENGTH must be non-zero too

FPNUM_LENGTH            = 6   // If FP_DIGITS is non-zero:
                              //   specifies the desired length of output string.
                              //   IDA will print the number in regular (non-scientific)
                              //   notation if possible.
                              // else
                              //   controls the notation used to print the number:
                              //   if the abs(number exponent) <= FPNUM_LENGTH
                              //     print in regular notation
                              //   else
                              //     print in scientific notation

// Example: to display numbers in reasonable range (0.00001..10000.0) nicely
//      FPNUM_DIGITS=0
//      FPNUM_LENGTH=5
// Too big and too small numbers will be printed using the scientific notation

// Example: to display numbers nicely formatted with constant width (8) and
//          constant decimal point position(3):
//      FPNUM_DIGITS=3
//      FPNUM_LENGTH=8
// IDA will print numbers in regular notation if possible.
// Attention, this setting will truncate all values to 3 digits after the decimal point

// Example: print numbers in scientific notation
//      FPNUM_DIGITS=0
//      FPNUM_LENGTH=0

// Example: forbidden combination:
//      FPNUM_DIGITS=5
//      FPNUM_LENGTH=0

//-------------------------------------------------------------------------
//
//      Text representation in the graph mode
//
//-------------------------------------------------------------------------
GRAPH_COMMENTS_INDENTION    = 24        // Indention of short comments
GRAPH_INDENTION             = 0         // Indention of instructions
GRAPH_MARGIN                = 40        // Max node width
GRAPH_SHOW_LINEPREFIXES     = NO        // Show line prefixes (like 1000:0000)
GRAPH_SHOW_XREFS            = 0         // Show no xrefs (use node title button for them)
GRAPH_OPCODE_BYTES          = 0         // don't display instruction/data bytes

//-------------------------------------------------------------------------
//
//      ASCII strings & names
//
//-------------------------------------------------------------------------

STRLIT_GENNAMES          = YES          // Generate names when making
                                        // an ASCII string
STRLIT_TYPE_AUTO         = YES          // Should IDA mark generated ascii names
                                        // as 'autogenerated'?
                                        // Autogenerated names will be deleted
                                        // when the ascii string is deleted
                                        // Also, they are displayed with the
                                        // same color as dummy names.
STRLIT_LINEBREAK         = '\n'         // This char forces IDA
                                        // to start a new line
STRLIT_PREFIX            = "a"          // This prefix is used when a new
                                        // name is generated

#define STRTYPE_C         0             // C-style string.
#define STRTYPE_C_16      1             // Zero-terminated 16bit chars
#define STRTYPE_C_32      2             // Zero-terminated 32bit chars
#define STRTYPE_PASCAL    4             // Pascal-style, one-byte length prefix
#define STRTYPE_PASCAL_16 5             // Pascal-style, 16bit chars, one-byte length prefix
#define STRTYPE_LEN2      8             // Pascal-style, two-byte length prefix
#define STRTYPE_LEN2_16   9             // Pascal-style, 16bit chars, two-byte length prefix
#define STRTYPE_LEN4      12            // Pascal-style, two-byte length prefix
#define STRTYPE_LEN4_16   13            // Pascal-style, 16bit chars, two-byte length prefix
STRLIT_STYLE             = STRTYPE_C    // Default is C-style

STRLIT_SERIAL            = NO           // Serial names are disabled
STRLIT_SERNUM            = 0            // Number to start serial names
STRLIT_ZEROES            = 0            // Number of leading zeroes in
                                        // serial names
STRLIT_COMMENT           = YES          // Generate auto comment for
                                        // ascii references. This option will
                                        // display the beginning of ascii string
                                        // at the instruction which refers
                                        // to the string
STRLIT_SAVECASE          = NO           // Preserve case of ascii strings for identifiers

        // type of generated names: (dummy names)
#define NM_REL_OFF      0
#define NM_PTR_OFF      1
#define NM_NAM_OFF      2
#define NM_REL_EA       3
#define NM_PTR_EA       4
#define NM_NAM_EA       5
#define NM_EA           6
#define NM_EA4          7
#define NM_EA8          8
#define NM_SHORT        9
#define NM_SERIAL       10
DUMMY_NAMES_TYPE        = NM_EA

MAX_AUTONAME_LEN        = 15            // Maximal length of new autogenerated names
                                        // (you may specify values up to 511)
        //
        // NOTE: As far as I know some assemblers can't handle such
        // a long names. For example, Table Driven Assembler
        // supports names' length up to 13.
        //      BE CAREFUL!

// Types of names that must be included into the list of names
// (this list usually appears by pressing Ctrl-L)
//      normal    1
//      public    2
//      auto      4
//      weak      8

LIST_NAMES              = 0x07  // default: include normal, public, auto

//-------------------------------------------------------------------------

//      Representation of demangled names
//      There are two predefined forms of demangled names: short and long forms.
//      Form of a demangled names is determined by combination of bits.
//      Each bit inhibits or permits some part of the demangled name.

                                    // Pointer modifiers:
#define MNG_DEFNEAR      0x00000000 //   inhibit near, display everything else
#define MNG_DEFNEARANY   0x00000001 //   inhibit near/__ptr64, display everything else
#define MNG_DEFFAR       0x00000002 //   inhibit far, display everything else
#define MNG_NOPTRTYP16   0x00000003 //   inhibit everything (disables vc7-extensions)
#define MNG_DEFHUGE      0x00000004 //   inhibit huge, display everything else
#define MNG_DEFPTR64     0x00000005 //   inhibit __pt64, display everything else
                                    //   ATT: in 64bit must be + MNG_NOTYPE|MNG_NOCALLC
#define MNG_DEFNONE      0x00000006 //   display all pointer modifiers
#define MNG_NOPTRTYP     0x00000007 //   inhibit all pointer modifiers

#define MNG_NODEFINIT    0x00000008 // Inhibit everything except the main name
                                    // This flag is not recommended
                                    // for __fastcall/__stdcall GCC3 names
                                    // because there is a high probablity of
                                    // incorrect demangling. Use it only when
                                    // you are sure that the input is a
                                    // cygwin/mingw function name
#define MNG_NOUNDERSCORE 0x00000010 // Inhibit underscores in __ccall, __pascal... +
#define MNG_NOTYPE       0x00000020 // Inhibit callc&based
#define MNG_NORETTYPE    0x00000040 // Inhibit return type of functions
#define MNG_NOBASEDT     0x00000080 // Inhibit base types
                                    //   NOTE: also inhibits "__linkproc__"
#define MNG_NOCALLC      0x00000100 // Inhibit __pascal/__ccall/etc
#define MNG_NOPOSTFC     0x00000200 // Inhibit postfix const
#define MNG_NOSCTYP      0x00000400 // Inhibit public/private/protected
#define MNG_NOTHROW      0x00000800 // Inhibit throw description
#define MNG_NOSTVIR      0x00001000 // Inhibit "static" & "virtual"
#define MNG_NOECSU       0x00002000 // Inhibit class/struct/union/enum
#define MNG_NOCSVOL      0x00004000 // Inhibit const/volatile/restrict
                                    //   NOTE: also inhibits "__unaligned"
#define MNG_NOCLOSUR     0x00008000 // Inhibit __closure for borland
#define MNG_NOUNALG      0x00010000 // Inhibit __unaligned (see NOCSVOL)
#define MNG_NOMANAGE     0x00020000 // Inhibit __pin/__box/__gc for ms(.net)
#define MNG_SHORT_S      0x00100000 // signed (int) is displayed as s(int)
#define MNG_SHORT_U      0x00200000 // unsigned (int) is displayed as u(int)
#define MNG_ZPT_SPACE    0x00400000 // Display space after comma in the arglist
#define MNG_DROP_IMP     0x00800000 // Inhibit __declspec(dllimport)
#define MNG_IGN_ANYWAY   0x02000000 // Ingore '_nn' at the end of name
#define MNG_IGN_JMP      0x04000000 // Ingore 'j_'  at the beginning of name
#define MNG_MOVE_JMP     0x08000000 // Move 'j_' prefix to the demangled name
                                    // If both MNG_IGN_JMP and MNG_MOVE_JMP
                                    // are set then move the prefix only if
                                    // the name was not truncated

ShortNameForm   =       0x0EA3BE67      // short form of demangled names
LongNameForm    =       0x06400007      // long  form of demangled names

#define DEMNAM_CMNT  0                  // comments
#define DEMNAM_NAME  1                  // regular names
#define DEMNAM_NONE  2                  // don't display

DemangleNames   = DEMNAM_CMNT           // Show demangled names as comments

DEMNAME_FIRST   = NO                // YES means that demangled name overrides
                                    // type info if both are present

//-------------------------------------------------------------------------
//
//      Character translations and allowed character lists
//
//-------------------------------------------------------------------------

// the following characters are allowed in strings, i.e.
// in order to find end of a string IDA looks for a character
// which doesn't belong to this array:
// Note about CURRENT_CULTURE:
//  - if the IDB's default encoding for 1-byte/symbol strings, is not
//    UTF-8, a "culture" will be derived from it. E.g., "windows-1252"
//    will yield culture "Latin".
//  - this cannot be done automatically for UTF-8, since UTF-8 covers
//    the whole Unicode codepoints space.
//  - regardless of whether a "culture" can be derived from the default
//    encoding or not, this can be overriden by the CULTURE configuration
//    property (see below)
//  - the CURRENT_CULTURE directive tells IDA to consider all
//    codepoints that are defined as part of that culture, as valid
//    in the string literals.
//  - this applies to codepoints >= 0x80
//  - there are 2 ways to mention a "culture":
//     1) the name of a .clt file in the cfg/ directory. E.g., "Latin"
//        will correspond to the "clt_Latin.clt" file. In this case,
//        the culture will contain all codepoints specified by the file.
//     2) the name of a Unicode "Block". In that case, the culture will
//        contain all the letters (Lu, Ll & Lo) that this block contains.
//        The list of blocks are available there:
//        http://www.fileformat.info/info/unicode/block/index.htm , and
//        spaces in the block names must be replaced with underscores
//        in order to obtain culture names.
//    (It is worth pointing out that, in the first case, the file can,
//    itself, include cultures: either by file name or as Unicode block)
StrlitChars =
        "\r\n\a\v\b\t\x1B"
        " !\"#$%&'()*+,-./0123456789:;<=>?"
        "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
        "`abcdefghijklmnopqrstuvwxyz{|}~",
        // Those should be part of the 'Latin_1_Supplement' culture
        // u00A1, // INVERTED EXCLAMATION MARK
        // u00BF, // INVERTED QUESTION MARK
        u00A9, // COPYRIGHT SIGN
        u00AE, // REGISTERED SIGN
        u20AC, // EURO SIGN
        u00B0, // DEGREE SIGN
        u2013, // EN DASH
        u2014, // EM DASH

        /// This would bring all the codepoints from the 'clt_Latin.clt' file
        // Culture_Latin,

        /// This would bring all the _letters_ of the "Greek and Coptic"
        /// Unicode block (there is no culture file with the name
        /// 'clt_Greek_and_Coptic.clt')
        // Culture_Greek_and_Coptic,

        CURRENT_CULTURE;


// The default 'culture' to use. Using -DCULTURE="foo" is a convenient way of
// specifying the culture for just one input file.
// CULTURE="Latin_1_Supplement"; // letters within range u+0080..u+00ff
// CULTURE="Cyrillic"; // letters within ranges u+0400..u+04FF, u+2DE0..u+2DFF, u+A640..u+A69F, u+1C80..u+1C8F, u+0500..u+052F
// CULTURE="Latin"; // all codepoints in clt_Latin.clt file
// CULTURE="all"; // all letters of all Unicode blocks, plus all codepoints in .clt files


// The default 1-byte encoding to use
// ENCODING="UTF-8"
// ENCODING="windows-1252"


// the following characters are allowed in user-defined names:

NameChars =
        "$?@"           // asm specific character
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz",
        // This would enable common Chinese characters in identifiers:
        // Culture_CJK_Unified_Ideographs,
        CURRENT_CULTURE;


// the following characters are allowed in mangled names.
// they will be substituted with the SUBSTCHAR during output if names
// are output in a mangled form.

MangleChars = "$:?([.)]"        // watcom
              "@$%?"            // microsoft
              "@$%&";           // borland


// the following characters are allowed in type names.

TypeNameChars =
        "_:$()`'{}"
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

//-------------------------------------------------------------------------
//      Built-in C parser parameters
//-------------------------------------------------------------------------

// Compiler-dependent settings: the folowing variables should be defined:
// HEADER_PATH - list of include directories separated by ';'
// PREDEFINED_MACROS - list of predefined macros
CC_PARMS = {
  vc {                             // Visual C++
     HEADER_PATH = "/Program Files/Microsoft Visual Studio/VC98/include"
     PREDEFINED_MACROS   = "_cdecl=__cdecl;"
                           "_pascal=__pascal;"
                           "_huge=__huge;"
                           "_near=__near;"
                           "_far=__far;"
                           "__inline=;"
                           "_inline=;"
                           "inline=;"
                           "CM_WINNT;"
                           "MPR50;"
                           "_INTEGRAL_MAX_BITS=64;"
                           "_MSC_VER=1400;"
                           "_CHAR_UNSIGNED=1;"
                           "_M_IX86=300;"
                           "__MT__=1;"
                           "__TLS__=1;"
                           "_Windows=1;"
                           "__WIN32__=1;"
                           "_WIN32_WINNT=0x0500;"
                           "WINVER=0x0500;"
                           "_WIN32=1;"
                           "OLEDBVER=0x0250;"
                           "SECURITY_WIN32;"
                           "WIN32_SUPPORT;"
                           "DBNTWIN32;"
                           "W32SUT_32;"
  }
  gcc {                            // GNU C++
     HEADER_PATH = "/usr/include"
     PREDEFINED_MACROS   = "__GNUC__=4;"
                           "__CHAR_BIT__=8;"
                           "unix=1;"
                           "__unix=1;"
                           "__unix__=1;"
                           "__ELF__=1;"
  }
  bcc {                            // Borland C++
    PREDEFINED_MACROS    = "__BORLANDC__=0x560;"
  }
  delphi {                         // Delphi
    PREDEFINED_MACROS    = "__BORLANDC__=0x550;"
  }
  watcom {                         // Watcom C++
    PREDEFINED_MACROS    = "__WATCOMC__=1100;"
  }
  visage {                         // Visual Age C++
    HEADER_PATH = "/usr/include"
    PREDEFINED_MACROS    = "__IBMC__=1110;"
                           "__IBMCPP__=1110;"
  }
  default {
     HEADER_PATH = ""
     PREDEFINED_MACROS   = ""
  }
}

// The namespace list is used to avoid failures caused by an heuristic rule
// that derives function types based on their names. For a name like A::B()
// it yields A::B(A*this). However, this rule should be turned off for namespace
// names, for example for std::terminate(). See also AF_MEMFUNC

CPP_NAMESPACES = "std;stdext;tr1;tr2;boost;boost::system;_STL;ATL;QT;"
                 "__gnu_cxx;__cxxabiv1;_com_util;"
                 "allocators;chrono;Concurrency;concurrency;details;Details;"
                 "direct3d;errc;fast_math;graphics;io_errc;msl;Platform;"
                 "precise_math;regex_constants;threads;utilities;Windows;"
                 "System;Sysutils;Classes;Controls;ExtCtrls;Forms;Menus;Comobj;Mapi;"
                 "CDO;Gdiplus;DllExports;MSXML2;MSXML6;BDATuningModel;";


// The maximum length of the list of trusted idb files.
// An idb file is considered as trusted if the user launched the debugger
// with it and saved the idb.
// If the current idb is marked as untrusted, IDA asks the user for a confirmation
// that s/he really wants to launch the debugger.
// The list of trusted databases (only md5 checksums of the idb header)
// is kept in %appdata%/Hex-Rays/IDA Pro/trusted_idb_list.bin
// If this parameter is zero, all idbs are considered as trusted.

MAX_TRUSTED_IDB_COUNT = 1024

//-------------------------------------------------------------------------
//      Processor specific parameters
//-------------------------------------------------------------------------
#ifdef __PC__                           // INTEL 80x86 PROCESSORS

//
// Location of Microsoft Debugging Engine Library (dbgeng.dll)
// This value is used by both the windmp (dump file loader) and the windbg
// debugger module. Please also refer to dbg_windbg.cfg
// (note: make sure there is a semicolon at the end)

//DBGTOOLS = "C:\\Program Files\\Debugging Tools for Windows (x86)\\";

USE_FPP                 = YES           // Floating Point Processor
                                        // instructions are enabled

// IBM PC specific analyzer options

PC_ANALYZE_PUSH         = YES           // Convert immediate operand of "push" to offset
                                        //
                                        //      In sequence
                                        //
                                        //              push    seg
                                        //              push    num
                                        //
                                        //      IDA will try to convert <num> to offset.
                                        //
PC_ANALYZE_NOP          = NO            // Convert db 90h after "jmp" to "nop"
                                        // Now it is better to turn off this option
                                        // because the final pass of the analysis will
                                        // convert 90h to nops more intelligently.
                                        //
                                        //      Sequence
                                        //
                                        //              jmp     short label
                                        //              db      90h
                                        //
                                        //      will be converted to
                                        //
                                        //              jmp     short label
                                        //              nop
                                        //
PC_ANALYZE_MOVOFF       = YES           // Convert immediate operand of "mov reg,..." to offset
                                        //
                                        //      In sequence
                                        //
                                        //              mov reg,    num
                                        //              mov segreg, immseg
                                        //
                                        //      where
                                        //        reg    - any general register
                                        //        num    - a number
                                        //        segreg - any segment register
                                        //        immseg - any form of operand representing a segment paragraph
                                        //
                                        //      <num> will be converted to an offset
                                        //
PC_ANALYZE_MOVOFF2      = YES           // Convert immediate operand of "mov memory,..." to offset
                                        //
                                        //      In sequence
                                        //
                                        //              mov x1, num
                                        //              mov x2, seg
                                        //
                                        //      where
                                        //              x1,x2 - any references to memory
                                        //
                                        //      <num> will be converted to an offset
                                        //
PC_ANALYZE_ZEROINS      = NO            // Disassemble zero opcode instructions
                                        //
                                        //      These instructions include:
                                        //
                                        //              00 00   add [bx+si], al
                                        //              00 00   add [eax], al
                                        //
                                        //      Usually this options is disabled
                                        //
PC_ANALYZE_BRTTI        = YES           // Advanced analysis of Borland's RTTI
                                        //
                                        //      This option allows ida to test and create RTTI structures.
                                        //      The analisys is triggered by renaming a location.
                                        //      If the new name can be demangled as Borland's RTTI descriptor name
                                        //      then the analisys is performed.
                                        //
PC_ANALYZE_UNKRTTI      = YES           // Check 'unknown_libname' for Borland's RTTI
                                        //
                                        //      This option allows IDA to test locations named as unknown_libname
                                        //      for RTTI structures. This option is meaningful only if the advanced
                                        //      analysis of RTTI is allowed.
                                        //
PC_ANALYZE_EXPFUNC      = YES           // Advanced analisys of catch/finally block
                                        //
                                        //      This option allows ida to check catch/finally exception blocks
                                        //
PC_ANALYZE_DIFBASE      = NO            // Allow references with different segment bases
                                        //
                                        //      This option allows IDA to display a reference to a symbol even if
                                        //      the reference value is not equal to the symbol value. For example,
                                        //      to refer to symbol \"x\" at 0000:0100 with expression 0010:0000
                                        //
PC_ANALYZE_NOPREF       = NO            // Don't display redundant instruction prefixes
                                        //
                                        //      This option makes the disassembly more readable by hiding the
                                        //      superfluous instruction prefixes which are not used in the
                                        //      instruction
                                        //
PC_ANALYZE_VXD          = YES           // Interpret int 20 as VxDcall
                                        //
                                        //      This option turns on interpretation of int 20h
                                        //      as a VxDcall/jump for 32-bit files
                                        //
PC_ANALYZE_FPEMU        = YES           // Enable FPU emulation instructions
                                        //
                                        //      This option turns on interpretation of int 3?h
                                        //      instructions as FPU emulation instructions
                                        //
PC_ANALYZE_SHOWRIP      = NO            // Explicit RIP-addressing
                                        //
                                        //      If this option is turned on, then RIP addressing is
                                        //      always represented with the RIP register
                                        //
                                        //              mov rax, [rip+1234]
                                        //
                                        //      Otherwise RIP addressing is replaced by the corresponding
                                        //      memory reference (when possible)
                                        //      This option is valid only for the 64-bit mode.
                                        //

PC_ANALYZE_NOSEH        = YES            // Disable SEH/EH analysis
                                        //      This option disables detection of Structured Exception (SEH)
                                        //      and C++ Exception (EH) handlers.

PC_ANALYZE_INT3STOP     = YES           // Analyze 'int 3' instructions
                                        //      If enabled, try to determine if execution stops after an int 3 instruction.
                                        //      For example, in the following code int 3 is likely a guard
                                        //      added by compiler to protect against return from a noret function:
                                        //
                                        //      call   __CxxThrowException@8
                                        //      int    3

PC_ANALYZE_MAX_SIMPLEX_SIZE = 10000     // Do not use the simplex method if the
                                        // number of variables is greater than this.
                                        // It takes too long.

PE_MAKE_IDATA           = YES           // Create imports segment for PE files
PE_LOAD_RESOURCES       = NO            // Load resources for PE files
PE_CREATE_FLAT_GROUP    = NO            // Create FLAT group for PE files


SHOW_AUTOCOMMENTS       = NO // Don't display comments for every instruction

ANALYSIS        = 0xDFFFFFF7ULL // Enable 'noret' analysis
                                // Enable SP analysis

#endif // __PC__
//-------------------------------------------------------------------------
#ifdef __JAVA__
SHOW_BORDERS            = NO            // Borders between data/code
SHOW_LINEPREFIXES       = NO            // No Show line prefixes (1000:0000)
SHOW_SEGXREFS           = NO            // No Show segment part of addresses
                                        // in cross-references
DUMMY_NAMES_TYPE        = NM_SHORT      // See 'dummy names' for explanations
MAX_DATALINE_LENGTH     = 77            // Data directives (db,dw, etc):
                                        //   max length of argument string
SHOW_XREFS              = 1             // Show 1 cross-reference
COMMENTS_INDENTION      = 47            // Indention for on-line comments
//
// Table of characters which are allowed in class, field, and method names.
// This table is created dynamically by the java module.
// Java supports any unicode LetterOrDigit character as 'name'-character,
// but IDA curently does not support the unicode output. Theoretically it is
// possible to enable any character in the current codepage as 'namechar' but
// there will be a problem with IDA databases. A old database will look wrong
// if opened on a computer with a different codepage. For this reason
// only english letter, digits, '$' and '_' are allowed in the names.
// (see java langspec).
//
NameChars = "";
//
// Table of characters which are allowed in ASCII strings, i.e. in
// CONSTANT_String arguments, Source File Name, SourceDebugExtension, etc.
// This table not used by the java module - currently IDA accepts only
// characters < 0x7F (english characters) and encoded unicode character
// for the CURRENT locale (cidition: the locale is NOT mbcs, which means
// that japanese, thai, etc will not work)
//
StrlitChars = "";
//

JAVA_MULTILINE_DEBUG	=	YES	// Force a new line at every LF
					// in the '.debug' directive

JAVA_HIDE_STACKMAP	=	NO	// Hide '.stack' verification areas

JAVA_AUTO_STRING	=	NO	// Make 'prompt' string after every
					// LR in quoted strings

JAVA_ASMFILE_CONVERT	=	YES	// Create jasmin-compatible
                                        // asm-file and change
					// the encoding from OEM to ANSI
                                        // (jasmin expects ANSI encoding)

JAVA_ENABLE_ENCODING	=	YES     // Convert unicode characters in
                                        // strings constants to ascii
                                        // characters (for the current
 					// locale).

JAVA_NOPATH_ATTRIBUTE	=	NO	// If 'YES', filename in '.attribute'
					// directives is specified without path.

// options for loader

JAVA_UNKATTR_REQUEST	=	YES	// If the loaded file contains 'unknown
                                        // attributes' and the 'manual load' is off
                                        // then IDA will ask your permission to
                                        // store the attributes to an external
                                        // file

JAVA_UNKATTR_WARNING	=	YES	// Include information of 'unknown
					// attributes' (if they were not saved
					// into external files) in the problem
                                        // list

JAVA_STARTASM_LIST	=	NO	// Display mode for new java files:
                                        // YES: listing mode
                                        // NO: jasmin mode

#endif // __JAVA__

//-------------------------------------------------------------------------

#ifdef __ARM__

ANALYSIS        = 0xDF8FFFF7ULL // Disable AF_IMMOFF, AF_DREFOFF, AF_DATOFF
                                // Enable 'noret' analysis, AF_VERSP

NameChars =
        ".$"
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

ARM_SIMPLIFY     = YES          // Simplify instructions and replace them
                                // by pseudo-instructions

ARM_NO_PTR_DEREF = NO           // Disable using of =label notation
                                // This notation makes disassembly cleaner

ARM_USE_MACROS   = YES          // Use macro-instructions like MOVL

ARM_NO_ARM_THUMB_SWITCH = NO    // No automatic ARM-THUMB switch

ARM_DISABLE_BL_JUMPS    = NO    // Disable detection of BL instructions used for long jumps (not calls) in Thumb mode

ARM_DEFAULT_ARCHITECTURE = "metaarm"; // Default architecture when not set by the loader. For details see documentation.

// ARM_DEFAULT_ARCHITECTURE = "ARMv7-A";

// for the vars below 0 means "no limit"
ARM_REGTRACK_VALS_SIZE   = 100  // max number of possible values of register;
ARM_REGTRACK_OP_RECURS   = 100  // max level of recursion when emulating
                                // the execution of instructions;
ARM_REGTRACK_BBLK_RECURS = 2000 // max level of recursion when unwinding
                                // the execution flow;
ARM_REGTRACK_CACHE_SIZE  = 5000 // max size of the cache for one register;

#endif // __ARM__

//-------------------------------------------------------------------------
#ifdef __TMS320C6__
INDENTION       = 8             // Indention of instructions
NameChars =
        "$_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";
ANALYSIS        = 0xDFEF9FF7ULL // All except AF_DREFOFF
#endif // __TMS320C6__

//-------------------------------------------------------------------------
#ifdef __TMS320C54__

TMS320C54_IO   =  YES		    // Use I/O definitions from the configuration
								// file in macro instructions.

TMS320C54_MMR  =  YES			// Replace addresses by an equivalent memory
								// mapped register.

TMS320C54_DSEG =  0x10000		// Default data segment address

#endif // __TMS320C54__

//-------------------------------------------------------------------------
#ifdef __PPC__          // PowerPC processor

NameChars =
        "_0123456789."
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";
                        // preserve the following characters in
                        // names (AIX assembler has .rename directive)
MangleChars = "!@#$%^&*()+-=[]\\{}|;':,/<>?`~ ";

ANALYSIS        = 0xDFFFFFB7ULL // Don't create function if data xref data->code32 exists
                                // (AIX XCOFF has many references from data
                                //  segment to strings in the code segment)
                                // Enable 'noret' analysis
                                // Enable SP analysis

DUMMY_NAMES_TYPE = NM_EA

MAX_DATALINE_LENGTH = 250       // this stupid AIX assembler can't digest
                                // a string without a trailing zero
                                // and we are forced to display
                                // everything on one line

PPC_LISOFF       = NO           // Aggressively convert lis/addi pairs to
                                // offsets (only if they refer to an
                                // existing address)

PPC_CREATE_SUBI  = NO           // If enabled, IDA will replace addi
                                // instructions with negative values by
                                // subi pseudo-instructions

// extra instructions to decode
// NB! AltiVec, SPE, VMX128 and Paired Singles are all mutually exclusive

#define ISA_ALTIVEC     0x0001  // AltiVec SIMD instructions
#define ISA_SPE         0x0002  // SPE (Signal Processing Engine) instructions
#define ISA_VLE         0x0004  // VLE (variable-length encoding) instructions
#define ISA_VMX128      0x0003  // VMX128 SIMD instructions (Xbox360)
#define ISA_PAIRED      0x0008  // Paired Singles instructions (Gekko)
#define ISA_SERVER      0x0100  // ISA Server environment (otherwise embedded)

PPC_ISA_SUPPORT       = 0x0101  // This value is combination of the bits above

// The following keywords can be used to specify TOC, SDA base, and MMIO base
// from idc scripts like this: ChangeConfig("PPC_TOC=0x123456");
//  PPC_TOC       - TOC (r2) address in the AIX or 64-bit System V ABI or
//                  SDA2 address in the Embedded System V ABI
//  PPC_SDA_BASE  - SDA (r13) address in the System V ABI
//  PPC_MMIO_BASE - MMIO base

// how to show references with SDA register (r13),
// non-trivial values (SDA/SIMPLIFY) may be used in the Embedded
// environment only and when the SDA base is set
#define PPC_SDAREFS_NO        0 // as usual: (var - <sda_base>)(r13)
#define PPC_SDAREFS_SDA       1 // show @sda, do not show base: var@sda(r13)
#define PPC_SDAREFS_SIMPLIFY  2 // w/o base register: var
PPC_SDAREFS = PPC_SDAREFS_NO

// for the vars below 0 means "no limit"
PPC_REGTRACK_VALS_SIZE   = 10   // max number of possible values of register;
PPC_REGTRACK_OP_RECURS   = 100  // max level of recursion when emulating
                                // the execution of instructions;
PPC_REGTRACK_BBLK_RECURS = 2000 // max level of recursion when unwinding
                                // the execution flow;
PPC_REGTRACK_CACHE_SIZE  = 5000 // max size of the cache for one register;

// ABI specification
#define PPC_ABI_RETSTRREG   0x0001  // Return structures smaller than 8 bytes in registers
#define PPC_ABI_LDBL_IS_DBL 0x0002  // long double is double
#define PPC_ABI_NOTALIGNUDT 0x0004  // the ABI of passing aggregates with 16-byte alignment has
                                    // changed in GCC 5. It conforms the "64-bit PowerPC ELF ABI
                                    // Supplement 1.9" now, set it for GCC4 only.
#define PPC_ABI_EMBEDDED    0x0008  // Embedded System V ABI as described in the "Power
                                    // Architecture 32-bit Application Binary Interface Supplement
                                    // 1.0 - Linux & Embedded".

PPC_FIX_GNU_VLEADRELOC_BUG = NO // There is a bug in GNU toolchain for PPC. It swaps relocs
                                // R_PPC_VLE_HA16A and R_PPC_VLE_HA16D (and also some others).
                                // See https://sourceware.org/bugzilla/show_bug.cgi?id=20744
                                // Set this var to process relocs R_PPC_VLE.*[AD] as GNU loader does.

#endif  // __PPC__

//-------------------------------------------------------------------------
#ifdef __80196__                // Intel 80196 processor

DUMMY_NAMES_TYPE = NM_SHORT

#endif  // __80196__

//-------------------------------------------------------------------------
#ifdef __I51__                  // Intel 8051, 80251 processors

DUMMY_NAMES_TYPE = NM_SHORT

#endif  // __I51__

//-------------------------------------------------------------------------
#ifdef __PDP11__                  // Digital PDP-11 processor

// Use character translation?

PDP_XLAT_ASCII = NO

NameChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_";

#endif  // __PDP11__

//-------------------------------------------------------------------------
#ifdef __SH3__                  // Hitachi SH3 processor

ANALYSIS        = 0xDFFF9FB7ULL // Don't create function if data xref data->code32 exists
                                // (PE execs have many Unicode strings in the code segment)

DUMMY_NAMES_TYPE = NM_EA

SH3_INLINE_IMMVALS = YES        // Put the immediates loaded from the literal pool into the instruction itself

#endif  // __SH3__

//-------------------------------------------------------------------------
#ifdef __MIPS__                 // MIPS processor

DUMMY_NAMES_TYPE = NM_EA

MIPS_MNEMONIC    = YES          // Use mnemonic register names
MIPS_SIMPLIFY    = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
MIPS_STRICT      = NO           // Strictly adhere to instruction specifications
MIPS_MACRO       = YES          // Use macros
MIPS_MACRO_RESPECT_XREFS = YES  // When looking back for the "lui" instruction,
                                // stop when an xrefed instruction is found
MIPS_MACRO_HIDDEN_R1 = YES      // Allow hidden modification of $1 in macros

MIPS_SIMPLIFY_GP = YES          // Simplify $gp expressions

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // LUI instruction

#endif  // __MIPS__

//-------------------------------------------------------------------------
#ifdef __PIC__                  // PIC processor

DUMMY_NAMES_TYPE = NM_NAM_OFF
PIC_MACRO        = YES          // Use macros

#endif  // __PIC__

//-------------------------------------------------------------------------
#ifdef __SPARC__                // SPARC processor

ANALYSIS         = 0xDFDF9FF7ULL// Disable AF_IMMOFF

DUMMY_NAMES_TYPE = NM_EA

SPARC_SIMPLIFY   = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
SPARC_STRICT     = NO           // Strictly adhere to instruction specifications
SPARC_MACRO      = YES          // Use macros
SPARC_V8         = NO           // V8 architecture disassembly

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // SETHI instruction
#endif  // __SPARC__

//-------------------------------------------------------------------------
#ifdef __ALPHA__                // DEC Alpha processor

DUMMY_NAMES_TYPE = NM_EA

ALPHA_SIMPLIFY   = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
ALPHA_STRICT     = NO           // Strictly adhere to instruction specifications
ALPHA_MACRO      = YES          // Use macros
ALPHA_MNEMONIC   = NO           // Use mnemonic register names

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // SETHI instruction

#endif  // __ALPHA__

//-------------------------------------------------------------------------
#ifdef __HPPA__                 // HP PA-RISC processor

DUMMY_NAMES_TYPE = NM_EA

HPPA_SIMPLIFY    = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
HPPA_MNEMONIC    = NO           // Use mnemonic register names
HPPA_PSW_W       = NO           // Consider programs as 64bit?

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // ADDIL/LDIL instructions

NameChars =
        "_0123456789."
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

SHOW_BASIC_BLOCKS       = YES   // Generate an empty line at the end of basic blocks

#endif  // __HPPA__

//-------------------------------------------------------------------------
#ifdef __DSP56K__               // Motorola 56000 (5600x) processor

DUMMY_NAMES_TYPE        = NM_SHORT

PACK_DATABASE           = 2     // deflate

#endif  // __DSP56K__

//-------------------------------------------------------------------------
// Intel Itanium IA64 (module name in x64 builds is: IA)
#if !defined(__X64__) && defined(__IA64__) || defined(__X64__) && defined(__IA__)

DUMMY_NAMES_TYPE = NM_EA

NameChars =
        "_0123456789."
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // memory reference addresses
#endif  // __IA64__

//-------------------------------------------------------------------------
#ifdef __CLI__                  // Microsoft.Net Common Language Infrastructure

NameChars =
        "$?@."           // asm specific character
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

MangleChars =
      "!#$%&'()*+,-./0123456789:;<=>?"
      "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_"
      "`abcdefghijklmnopqrstuvwxyz{|}~",
      u007F..u10FFFF & Category_Lo,
      u007F..u10FFFF & Category_Ll,
      u007F..u10FFFF & Category_Lu;


SHOW_BORDERS            = NO
SHOW_SEGMENT_BORDERS    = NO

INDENTION               = 4   // Indention of instructions
COMMENTS_INDENTION      = 40  // Indention of short comments
SHOW_LINEPREFIXES       = NO  // Show line prefixes (like 1000:0000)

#endif  // __CLI__

//-------------------------------------------------------------------------
#ifdef __MC68__                 // MC68K, 68xxx, 68000

ANALYSIS        = 0xdfffdff7ULL // Enable 'noret' analysis

MC68K_UNSIGNED_OPS      = YES   // Immediate operands are unsigned by default

#endif // __MC68__

//-------------------------------------------------------------------------
#ifdef __MC6812__               // MC6812

#endif // __MC68__

//-------------------------------------------------------------------------
#ifdef __H8__                   // H8

NameChars =
        "$?" // no '@' character
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

#endif  // __H8__

//-------------------------------------------------------------------------
#ifdef __H8500__                // H8/500

NameChars =
        "$?" // no '@' character
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

H8500_MIXED_SIZE        = YES

#endif  // __H8500__

//-------------------------------------------------------------------------
#ifdef __I960__                 // Intel 960

I960_STRICT             = YES

#endif  // __H8500__

//-------------------------------------------------------------------------
#ifdef __TRIMEDIA__             // TriMedia

TRIMEDIA_PSEUDO         = NO    // Don't use pseudo instructions since
                                // the assembler doesn't understand them

TRIMEDIA_GUARD0         = NO    // Allow R0 as the guard
                                // If this option is on, IDA will disassemble instructions
                                // with R0 as the guard\

TRIMEDIA_ONENOP         = YES   // Display NOP cycle one 1 line
                                // If this option is on, IDA will display a cycle with all
                                // NOP operations on one line

//ANALYSIS                = 0xDFCF9FF7ULL

#endif  // __TRIMEDIA__

//-------------------------------------------------------------------------
#ifdef __F2MC__                 // Fujitsu F2MC

F2MC_MACRO              = YES   // Use macro instructions

#endif  // __F2MC__

//-------------------------------------------------------------------------
#ifdef __TMS32054__             // Texas Instruments TMS320C54

TMS320C54_IO            = YES   // Use I/O definitions
TMS320C54_MMR           = YES   // Detect memory mapped registers

#endif  // __TMS32054__

//-------------------------------------------------------------------------
#ifdef __TRICORE__              // Infineon TRICORE

TRICORE_REGISTER_TRACKING = YES    // Enable register tracking

LOOKBACK                  = 16  // Look back up to 16 instructions to find
                                // memory reference addresses

// The following 2 parameters are to be used with ChangeConfig() IDC function:

// TRICORE_IORESP = 7              // The actions be carried out by TRICORE_DEVICE
//                                 // Bit combination of:
//                                 //   1 rename port names in memory
//                                 //   2 respect "area" directives
//                                 //   4 respect interrupt information
// TRICORE_DEVICE = "tc1766"       // Device name (see tricore.cfg)

#endif  // __TMS32055__

//-------------------------------------------------------------------------
#ifdef __TMS32055__             // Texas Instruments TMS320C55

TMS320C55_IO            = YES   // Use I/O definitions
TMS320C55_MMR           = YES   // Detect memory mapped registers

#endif  // __TMS32055__

#endif // ____  second pass ends here
//-------------------------------------------------------------------------
//      User specific parameters
//-------------------------------------------------------------------------
//
//  If you don't want to modify IDA.CFG file then you can create a file called
//  IDAUSER.CFG and place additional parameters there.
//
//  The IDAUSER.CFG file should be placed in the following directory:
//      - unix:    $HOME/.idapro
//      - windows: %APPDATA%\Hex-Rays\IDA Pro
//
//  It will be called 2 times: in the first and second pass.
//  You can check the pass using
//      #ifdef ____
//        then it is the first pass
//      #else
//        it is the second pass
//      #endif
//
//  Some parameters must be defined in the first pass, some in the second.
//  See examples in this file.
//
#softinclude    <idauser.cfg>   // user defined macros can be
                                // defined in the 'idauser.cfg' file
                                // other parameters can be defined there too.
